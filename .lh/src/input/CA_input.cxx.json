{
    "sourceFile": "src/input/CA_input.cxx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 24,
            "patches": [
                {
                    "date": 1639711369033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1639711469662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,5 @@\n \n-\n-\n-\n-\n /*\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n@@ -11,31 +7,22 @@\n  mergesort2.cxx  contains a function that divides the input array into two halves, \n  calls itself for the two halves, and then merges the two sorted halves. \n  merge() function is merges two halves of the array. \n  \n- Merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted.\n+Initially, there is a grid with some cells which may be alive or dead. Our task to generate the next generation of cells based on the following rules: \n  \n \n-MergeSort(arr[], l,  r)\n-If r > l\n-     1. middle point to divide the array into two halves:  \n-             middle m = l+ (r-l)/2\n-     2. mergeSort for first half:   \n-             Call mergeSort(arr, l, m)\n-     3. mergeSort for second half:\n-             Call mergeSort(arr, m+1, r)\n-     4. Merge sorted subarrays:\n-              merge(arr, l, m, r)\n+    Any live cell with fewer than two live neighbors dies, as if caused by under population.\n+    Any live cell with two or three live neighbors lives on to the next generation.\n+    Any live cell with more than three live neighbors dies, as if by overpopulation.\n+    Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Merge Sort\n \n */\n \n \n \n-\n-\n-\n #include <iostream>\n #include <utility>\n #include <math.h> \n #include \"CellularAutomata.h\"\n"
                },
                {
                    "date": 1639711485353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n     Any live cell with two or three live neighbors lives on to the next generation.\n     Any live cell with more than three live neighbors dies, as if by overpopulation.\n     Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n-C++ program for Merge Sort\n+C++ program for Cellular Automata\n \n */\n \n \n"
                },
                {
                    "date": 1639711491439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- mergesort2.cxx  contains a function that divides the input array into two halves, \n+ .cxx  contains a function that divides the input array into two halves, \n  calls itself for the two halves, and then merges the two sorted halves. \n  merge() function is merges two halves of the array. \n  \n Initially, there is a grid with some cells which may be alive or dead. Our task to generate the next generation of cells based on the following rules: \n"
                },
                {
                    "date": 1639711496597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- .cxx  contains a function that divides the input array into two halves, \n+ CA_input.cxx  contains a function that divides the input array into two halves, \n  calls itself for the two halves, and then merges the two sorted halves. \n  merge() function is merges two halves of the array. \n  \n Initially, there is a grid with some cells which may be alive or dead. Our task to generate the next generation of cells based on the following rules: \n"
                },
                {
                    "date": 1639711506943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,14 +3,10 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx  contains a function that divides the input array into two halves, \n- calls itself for the two halves, and then merges the two sorted halves. \n- merge() function is merges two halves of the array. \n+ CA_input.cxx  contains a function there is a grid with some cells which may be alive or dead. Our task to generate the next generation of cells based on the following rules: \n  \n-Initially, there is a grid with some cells which may be alive or dead. Our task to generate the next generation of cells based on the following rules: \n- \n \n     Any live cell with fewer than two live neighbors dies, as if caused by under population.\n     Any live cell with two or three live neighbors lives on to the next generation.\n     Any live cell with more than three live neighbors dies, as if by overpopulation.\n"
                },
                {
                    "date": 1639711516348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,11 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx  contains a function there is a grid with some cells which may be alive or dead. Our task to generate the next generation of cells based on the following rules: \n+ CA_input.cxx  contains a function that there is a grid with some cells \n+ which may be alive or dead. Our task to generate the next generation of \n+ cells based on the following rules: \n  \n \n     Any live cell with fewer than two live neighbors dies, as if caused by under population.\n     Any live cell with two or three live neighbors lives on to the next generation.\n"
                },
                {
                    "date": 1639711522454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,11 +6,9 @@\n \n  CA_input.cxx  contains a function that there is a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: \n- \n-\n-    Any live cell with fewer than two live neighbors dies, as if caused by under population.\n+ Any live cell with fewer than two live neighbors dies, as if caused by under population.\n     Any live cell with two or three live neighbors lives on to the next generation.\n     Any live cell with more than three live neighbors dies, as if by overpopulation.\n     Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n"
                },
                {
                    "date": 1639711527978,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,11 +5,10 @@\n   Fall 2021\n \n  CA_input.cxx  contains a function that there is a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n- cells based on the following rules: \n- Any live cell with fewer than two live neighbors dies, as if caused by under population.\n-    Any live cell with two or three live neighbors lives on to the next generation.\n+ cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n+  Any live cell with two or three live neighbors lives on to the next generation.\n     Any live cell with more than three live neighbors dies, as if by overpopulation.\n     Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n"
                },
                {
                    "date": 1639711533649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,10 +6,10 @@\n \n  CA_input.cxx  contains a function that there is a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n-  Any live cell with two or three live neighbors lives on to the next generation.\n-    Any live cell with more than three live neighbors dies, as if by overpopulation.\n+ Any live cell with two or three live neighbors lives on to the next generation.\n+ Any live cell with more than three live neighbors dies, as if by overpopulation.\n     Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n \n"
                },
                {
                    "date": 1639711545006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,14 +3,14 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx  contains a function that there is a grid with some cells \n+ CA_input.cxx contains a function that there is a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n  Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n-    Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n+ Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n \n */\n"
                },
                {
                    "date": 1639711584106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx contains a function that there is a grid with some cells \n+ CA_input.cxx contains a function with a s a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n  Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n"
                },
                {
                    "date": 1639711605276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,11 +3,11 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx contains a function with a s a grid with some cells \n+ CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n- cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n+ cells based on the following rules: 1)Any live cell with fewer than two live neighbors dies, as if caused by under population.\n  Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n"
                },
                {
                    "date": 1639711619363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n   Fall 2021\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n- cells based on the following rules: 1)Any live cell with fewer than two live neighbors dies, as if caused by under population.\n+ cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n  Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n"
                },
                {
                    "date": 1639711635865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n   Fall 2021\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n- cells based on the following rules: Any live cell with fewer than two live neighbors dies, as if caused by under population.\n+ cells based on the following rules: A live cell with less than two live neighbors dies, as if caused by under population.\n  Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n"
                },
                {
                    "date": 1639711652549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n   Fall 2021\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n- cells based on the following rules: A live cell with less than two live neighbors dies, as if caused by under population.\n+cells based on the following rules: A live cell with less than two live neighbors dies, as if caused by under population.\n  Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n"
                },
                {
                    "date": 1639711660085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,10 +5,9 @@\n   Fall 2021\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n-cells based on the following rules: A live cell with less than two live neighbors dies, as if caused by under population.\n- Any live cell with two or three live neighbors lives on to the next generation.\n+ cells based on the following rules: A live cell with less than two live neighbors dies, Any live cell with two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n"
                },
                {
                    "date": 1639711665520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,10 @@\n   Fall 2021\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n- cells based on the following rules: A live cell with less than two live neighbors dies, Any live cell with two or three live neighbors lives on to the next generation.\n+ cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n+ two or three live neighbors lives on to the next generation.\n  Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n"
                },
                {
                    "date": 1639711678672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,10 +6,9 @@\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n- two or three live neighbors lives on to the next generation.\n- Any live cell with more than three live neighbors dies, as if by overpopulation.\n+ two or three live neighbors lives on to the next generation, Any live cell with more than three live neighbors dies, as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n \n"
                },
                {
                    "date": 1639711685763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,10 @@\n \n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n- two or three live neighbors lives on to the next generation, Any live cell with more than three live neighbors dies, as if by overpopulation.\n+ two or three live neighbors lives on to the next generation, live cell with more than three live neighbors dies\n+  as if by overpopulation.\n  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n \n"
                },
                {
                    "date": 1639711692520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,10 +7,9 @@\n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n  two or three live neighbors lives on to the next generation, live cell with more than three live neighbors dies\n-  as if by overpopulation.\n- Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n+ and any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n \n C++ program for Cellular Automata\n \n */\n"
                },
                {
                    "date": 1639711698965,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n  CA_input.cxx contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n  two or three live neighbors lives on to the next generation, live cell with more than three live neighbors dies\n- and any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n+ and any dead cell with exactly three live neighbors becomes a live cell(reproduction).\n \n C++ program for Cellular Automata\n \n */\n"
                },
                {
                    "date": 1639711704311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx contains a function with a grid with some cells \n+ CA_input.cxx: contains a function with a grid with some cells \n  which may be alive or dead. Our task to generate the next generation of \n  cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n  two or three live neighbors lives on to the next generation, live cell with more than three live neighbors dies\n  and any dead cell with exactly three live neighbors becomes a live cell(reproduction).\n"
                },
                {
                    "date": 1639711715667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,10 +3,10 @@\n   UC Berkeley - MSSE Program\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n- CA_input.cxx: contains a function with a grid with some cells \n- which may be alive or dead. Our task to generate the next generation of \n+ CA_input.cxx: contains functions with a grid with some cells \n+ which may be alive or dead. It generate the next generation of \n  cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n  two or three live neighbors lives on to the next generation, live cell with more than three live neighbors dies\n  and any dead cell with exactly three live neighbors becomes a live cell(reproduction).\n \n"
                },
                {
                    "date": 1639711723195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,10 @@\n   Chem 279-B  Introduction to Software Engineering\n   Fall 2021\n \n  CA_input.cxx: contains functions with a grid with some cells \n- which may be alive or dead. It generate the next generation of \n- cells based on the following rules: A live cell with less than two live neighbors dies, live cell with \n+ which may be alive or dead. It generates the next generation of \n+ cells based on these rules: A live cell with less than two live neighbors dies, live cell with \n  two or three live neighbors lives on to the next generation, live cell with more than three live neighbors dies\n  and any dead cell with exactly three live neighbors becomes a live cell(reproduction).\n \n C++ program for Cellular Automata\n"
                }
            ],
            "date": 1639711369033,
            "name": "Commit-0",
            "content": "\n\n\n\n\n/*\n  UC Berkeley - MSSE Program\n  Chem 279-B  Introduction to Software Engineering\n  Fall 2021\n\n mergesort2.cxx  contains a function that divides the input array into two halves, \n calls itself for the two halves, and then merges the two sorted halves. \n merge() function is merges two halves of the array. \n \n Merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted.\n \n\nMergeSort(arr[], l,  r)\nIf r > l\n     1. middle point to divide the array into two halves:  \n             middle m = l+ (r-l)/2\n     2. mergeSort for first half:   \n             Call mergeSort(arr, l, m)\n     3. mergeSort for second half:\n             Call mergeSort(arr, m+1, r)\n     4. Merge sorted subarrays:\n              merge(arr, l, m, r)\n\nC++ program for Merge Sort\n\n*/\n\n\n\n\n\n\n#include <iostream>\n#include <utility>\n#include <math.h> \n#include \"CellularAutomata.h\"\n#include \"myutils.h\"\n\n// Constructor with data being passed in from the user.\nCellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::vector<std::vector<int> > data, std::string product, std::string reactor, std::pair<int, int> starting_position)\n{\n    // Will need to ensure that the integers in the legend cover the data that is input, if not it should throw an error.\n    _rows = rows;\n    _columns = columns;\n    _data = data;\n    _size = rows*columns;\n    _num_states = legend.size();\n    _legend = legend;\n    _product = product;\n    _reactor = reactor;\n    _starting_position = starting_position;\n}\n\n// Constructor with no data, but data is built randomly.\nCellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::string product, std::string reactor, std::pair<int, int> starting_position)\n{\n    _rows = rows;\n    _columns = columns;\n    _size = rows*columns;\n    _num_states = legend.size();\n    _legend = legend;\n    _product = product;\n    _reactor = reactor;\n    _starting_position = starting_position;\n    // Builds the initial _data structure to have enough vectors inside the vector of vectors to hold the data. This is equal to the bumber of rows.\n    _data.resize(_rows);\n    // Calls the Initialize function to build a Cellular Automata randomly with the specifications above.\n    CellularAutomata::Initialize_Rand();\n}\n\n// Constructor with no data, and data is built using density values passed in.\nCellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, std::pair<int, float> > legend, std::string product, std::string reactor, std::pair<int, int> starting_position)\n{\n    _rows = rows;\n    _columns = columns;\n    _size = rows*columns;\n    _num_states = legend.size();\n    _legend_density = legend;\n    _product = product;\n    _reactor = reactor;\n    _starting_position = starting_position;\n\n    // Builds the intial _data structure so that the vector of vector has values in it which will be replaced based on the densities of the variables.\n    _data.resize(_rows);\n    for (int row = 0; row < _rows; row++)\n    {\n        for (int column = 0; column < _columns; column++)\n        {\n            _data[row].push_back(0);\n        }\n    }\n    // Calls the Initialize function to build a Cellular Automata using densities given in the specifications above.\n    CellularAutomata::Initialize_Density();\n}\n\n// Function to initialize cellular automata data randomly.\nvoid CellularAutomata::Initialize_Rand()\n{   \n    // Grabs the max element in the legend map.\n    // Grabs the max element in the legend map, leaving out the reactor and product values (The reactor will be placed specifically by the user and the product will be placed after the compute steps).\n    std::cout << \"In intialize\" << std::endl;\n    int max = 0;\n    for(const auto &it : _legend)\n    {\n        if (it.second > max && it.first != _product && it.first != _reactor) \n        {\n            max = it.second;\n        }\n    }\n\n    // Grabs the min element in the legend map.\n    // Grabs the min element in the legend map, leaving out the reactor and product values (The reactor will be placed specifically by the user and the product will be placed after the compute steps).\n    int min = 2147483647;\n    for(auto it = _legend.begin(); it != _legend.end(); ++it )\n    for(const auto &it2 : _legend)\n    {\n        if (it2.second < min && it2.first != _product && it2.first != _reactor) \n        {\n            min = it2.second;\n        }\n    }\n\n    // Builds the Cellular automata randomly using the min and max values gotten above.\n    for (int row = 0; row < _rows; row++)\n    {\n        for (int column = 0; column < _columns; column++)\n        {\n            _data[row].push_back(generate_rand_int(min, max));\n        }\n    }\n\n    // Generates the starting position for the reactor variable which will cause changes throughout the Cellular Automata. Acceses using row major\n    _data[_starting_position.first][_starting_position.second] = _legend[_reactor]; \n}\n\n// Function to initialize cellular automata data using density.\nvoid CellularAutomata::Initialize_Density()\n{\n    // Sets the seed for the random float generator below\n    srand (static_cast <unsigned> (time(0)));\n    // Iterates through the legend map creates the cellular automata based on the density value.\n    for (int row = 0; row < _rows; row++)\n    {\n        for (int column = 0; column < _columns; column++)\n        {\n            for(const auto &it : _legend_density)\n            {\n                if (it.second.second != 0.0)\n                {\n                    // Generates a random floating number from 0.0 to 1.0\n                    float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\n                    // If the number is less than the density value, then the value at that data index is equal to the value of the variable.\n                    if (r < it.second.second)\n                    {\n                        _data[row][column] = (it.second.first);\n                    }\n                }\n            }\n        }\n    }\n\n    // Generates the starting position for the reactor variable which will cause changes throughout the Cellular Automata. Acceses using row major\n    _data[_starting_position.first][_starting_position.second] = _legend_density[_reactor].first; \n}\n\n\n// Code to evaluate von neumman neighborhood where r = 1 with periodic bounds.\nstd::vector<int> CellularAutomata::vn_neighborhood(int row, int column)\n{\n    std::vector<int> neighborhood;\n    int north = _data[(_rows + ((row-1) % _rows) ) % _rows][column];\n    neighborhood.push_back(north);\n    int west = _data[row][(_columns + ((column - 1) % _columns)) % _columns];\n    neighborhood.push_back(west);\n    int east = _data[row][(_columns + ((column + 1) % _columns)) % _columns];\n    neighborhood.push_back(east);\n    int south = _data[(_rows + ((row+1) % _rows) ) % _rows][column];\n    neighborhood.push_back(south);\n\n    // std::cout << \"North neighbour is: \" << north << std::endl;\n    // std::cout << \"East neighbour is: \" << east << std::endl;\n    // std::cout << \"South neighbour is: \" << south << std::endl;\n    // std::cout << \"West neighbour is: \" << west << std::endl;\n\n    return neighborhood;\n}\n\n// Code to evaluate moore neighborhood where r = 1 with periodic bounds.\nstd::vector<int> CellularAutomata::moore_neighborhood(int row, int column)\n{\n    int north = _data[(_rows + ((row-1) % _rows) ) % _rows][column];\n    int north_east = _data[(_rows + ((row-1) % _rows) ) % _rows][(_columns + ((column + 1) % _columns)) % _columns];\n    int east = _data[row][(_columns + ((column + 1) % _columns)) % _columns];\n    int south_east = _data[(_rows + ((row+1) % _rows) ) % _rows][(_columns + ((column + 1) % _columns)) % _columns];\n    int south = _data[(_rows + ((row+1) % _rows) ) % _rows][column];\n    int south_west = _data[(_rows + ((row+1) % _rows) ) % _rows][(_columns + ((column - 1) % _columns)) % _columns];\n    int west = _data[row][(_columns + ((column - 1) % _columns)) % _columns];\n    int north_west = _data[(_rows + ((row-1) % _rows) ) % _rows][(_columns + ((column - 1) % _columns)) % _columns];\n\n    std::vector<int> neighborhood;\n    neighborhood.push_back(north_west);\n    neighborhood.push_back(north);\n    neighborhood.push_back(north_east);\n    neighborhood.push_back(west);\n    neighborhood.push_back(east);\n    neighborhood.push_back(south_west);\n    neighborhood.push_back(south);\n    neighborhood.push_back(south_east);\n\n    // std::cout << \"North neighbour is: \" << north << std::endl;\n    // std::cout << \"North East neighbour is: \" << north_east << std::endl;\n    // std::cout << \"East neighbour is: \" << east << std::endl;\n    // std::cout << \"South East neighbour is: \" << south_east << std::endl;    \n    // std::cout << \"South neighbour is: \" << south << std::endl;\n    // std::cout << \"South West neighbour is: \" << south_west << std::endl;\n    // std::cout << \"West neighbour is: \" << west << std::endl;\n    // std::cout << \"North West neighbour is: \" << north_west << std::endl;\n\n    return neighborhood;\n}\n\nstd::vector<int> CellularAutomata::get_neighborhood(int x, int y,int neighborhood_num){\n  switch(neighborhood_num) {\n    case 1:\n      return moore_neighborhood(x,y);\n    case 2:\n      return vn_neighborhood(x,y);\n    default:\n      return moore_neighborhood(x,y);\n  }\n}\n\nvoid CellularAutomata::run(int num_steps, int rule_num, int neighborhood_num){\n  for(int i=0; i < num_steps; i++){\n    step(rule_num, neighborhood_num);\n    std::cout << \"Step \" << i << \": \" << std::endl;\n    print();\n  }\n}\n\n//logic for taking a single step of the CA simluation todo: document the funciton\nvoid CellularAutomata::step(int rule_num, int neighborhood_num){\n  for(int x = 0; x < _columns; x++){\n    for(int y = 0; y < _rows; y++){\n      std::vector<int> neighborhood = get_neighborhood(x,y,neighborhood_num);\n      _data[x][y] = transition_function(x,y,rule_num,neighborhood);\n    }\n  }\n}\n\n\nint CellularAutomata::transition_function(int x, int y, int rule_num, std::vector<int> neighborhood){\n  switch(rule_num) {\n    case 1:\n      return majority_rule(x, y, neighborhood);\n    case 2:\n      return purity_rule(x,y,neighborhood);\n    default:\n      return _data[x][y];\n  }\n}\n\n// logic for the majority rule todo:  add additional function documentation\nint CellularAutomata::majority_rule(int x, int y, std::vector<int> neighborhood){\n  int sum = 0;\n  for(int i = 0; i < neighborhood.size(); i++){\n    sum += neighborhood[i];\n  }\n\n  return round((double)sum/neighborhood.size());\n}\n\n// logic for the purity rule todo:  add additional function documentation\nint CellularAutomata::purity_rule(int x, int y, std::vector<int> neighborhood){\n  int sum = 0;\n  int current_val = _data[x][y];\n  for(int i = 0; i < neighborhood.size(); i++){\n    sum += (current_val+neighborhood[i]);\n  }\n\n  return sum % _num_states;\n}\n\n// Temporary print that is being used to test if the Initialize function is working as intended.\n// Print the formatted matrix out to the terminal using std::cout. Each row is printed with the first element of the Cellular Automata following an opening square bracket and all elements being seperated by commas. The last element of the Cellular Automata is also followed by a closing square bracket.\nvoid CellularAutomata::print()\n{\n    for(int i = 0; i < _rows; i++)\n    {\n        for(int j = 0; j < _columns; j++)\n        {\n            if ((i == _rows-1) && (j == _columns-1))\n            {\n                std::cout << _data[i][j] << \"]\";\n            }\n            else if ((i == 0) && (j == 0))\n            {\n                std::cout << \"[\" << _data[i][j] << \", \";\n            }\n            else\n            {\n                std::cout << _data[i][j] << \", \";\n            }\n        }\n        std::cout << std::endl;\n    }\n}\n"
        }
    ]
}