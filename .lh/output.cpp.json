{
    "sourceFile": "output.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1639548234824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1639548249355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,26 +5,301 @@\n \n \n \n \n+#include <iostream>\n+#include <utility>\n+#include <math.h> \n+#include \"CellularAutomata.h\"\n+#include \"myutils.h\"\n \n+// Constructor with data being passed in from the user.\n+CellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::vector<std::vector<int> > data, std::string product, std::string reactor, std::pair<int, int> starting_position)\n+{\n+    // Will need to ensure that the integers in the legend cover the data that is input, if not it should throw an error.\n+    _rows = rows;\n+    _columns = columns;\n+    _data = data;\n+    _size = rows*columns;\n+    _num_states = legend.size();\n+    _legend = legend;\n+    _product = product;\n+    _reactor = reactor;\n+    _starting_position = starting_position;\n+}\n \n+// Constructor with no data, but data is built randomly.\n+CellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::string product, std::string reactor, std::pair<int, int> starting_position)\n+{\n+    _rows = rows;\n+    _columns = columns;\n+    _size = rows*columns;\n+    _num_states = legend.size();\n+    _legend = legend;\n+    _product = product;\n+    _reactor = reactor;\n+    _starting_position = starting_position;\n+    // Builds the initial _data structure to have enough vectors inside the vector of vectors to hold the data. This is equal to the bumber of rows.\n+    _data.resize(_rows);\n+    // Calls the Initialize function to build a Cellular Automata randomly with the specifications above.\n+    CellularAutomata::Initialize_Rand();\n+}\n \n+// Constructor with no data, and data is built using density values passed in.\n+CellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, std::pair<int, float> > legend, std::string product, std::string reactor, std::pair<int, int> starting_position)\n+{\n+    _rows = rows;\n+    _columns = columns;\n+    _size = rows*columns;\n+    _num_states = legend.size();\n+    _legend_density = legend;\n+    _product = product;\n+    _reactor = reactor;\n+    _starting_position = starting_position;\n \n+    // Builds the intial _data structure so that the vector of vector has values in it which will be replaced based on the densities of the variables.\n+    _data.resize(_rows);\n+    for (int row = 0; row < _rows; row++)\n+    {\n+        for (int column = 0; column < _columns; column++)\n+        {\n+            _data[row].push_back(0);\n+        }\n+    }\n+    // Calls the Initialize function to build a Cellular Automata using densities given in the specifications above.\n+    CellularAutomata::Initialize_Density();\n+}\n \n+// Function to initialize cellular automata data randomly.\n+void CellularAutomata::Initialize_Rand()\n+{   \n+    // Grabs the max element in the legend map.\n+    // Grabs the max element in the legend map, leaving out the reactor and product values (The reactor will be placed specifically by the user and the product will be placed after the compute steps).\n+    std::cout << \"In intialize\" << std::endl;\n+    int max = 0;\n+    for(const auto &it : _legend)\n+    {\n+        if (it.second > max && it.first != _product && it.first != _reactor) \n+        {\n+            max = it.second;\n+        }\n+    }\n \n+    // Grabs the min element in the legend map.\n+    // Grabs the min element in the legend map, leaving out the reactor and product values (The reactor will be placed specifically by the user and the product will be placed after the compute steps).\n+    int min = 2147483647;\n+    for(auto it = _legend.begin(); it != _legend.end(); ++it )\n+    for(const auto &it2 : _legend)\n+    {\n+        if (it2.second < min && it2.first != _product && it2.first != _reactor) \n+        {\n+            min = it2.second;\n+        }\n+    }\n \n+    // Builds the Cellular automata randomly using the min and max values gotten above.\n+    for (int row = 0; row < _rows; row++)\n+    {\n+        for (int column = 0; column < _columns; column++)\n+        {\n+            _data[row].push_back(generate_rand_int(min, max));\n+        }\n+    }\n \n+    // Generates the starting position for the reactor variable which will cause changes throughout the Cellular Automata. Acceses using row major\n+    _data[_starting_position.first][_starting_position.second] = _legend[_reactor]; \n+}\n \n+// Function to initialize cellular automata data using density.\n+void CellularAutomata::Initialize_Density()\n+{\n+    // Sets the seed for the random float generator below\n+    srand (static_cast <unsigned> (time(0)));\n+    // Iterates through the legend map creates the cellular automata based on the density value.\n+    for (int row = 0; row < _rows; row++)\n+    {\n+        for (int column = 0; column < _columns; column++)\n+        {\n+            for(const auto &it : _legend_density)\n+            {\n+                if (it.second.second != 0.0)\n+                {\n+                    // Generates a random floating number from 0.0 to 1.0\n+                    float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\n+                    // If the number is less than the density value, then the value at that data index is equal to the value of the variable.\n+                    if (r < it.second.second)\n+                    {\n+                        _data[row][column] = (it.second.first);\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n+    // Generates the starting position for the reactor variable which will cause changes throughout the Cellular Automata. Acceses using row major\n+    _data[_starting_position.first][_starting_position.second] = _legend_density[_reactor].first; \n+}\n \n \n+// Code to evaluate von neumman neighborhood where r = 1 with periodic bounds.\n+std::vector<int> CellularAutomata::vn_neighborhood(int row, int column)\n+{\n+    std::vector<int> neighborhood;\n+    int north = _data[(_rows + ((row-1) % _rows) ) % _rows][column];\n+    neighborhood.push_back(north);\n+    int west = _data[row][(_columns + ((column - 1) % _columns)) % _columns];\n+    neighborhood.push_back(west);\n+    int east = _data[row][(_columns + ((column + 1) % _columns)) % _columns];\n+    neighborhood.push_back(east);\n+    int south = _data[(_rows + ((row+1) % _rows) ) % _rows][column];\n+    neighborhood.push_back(south);\n \n+    // std::cout << \"North neighbour is: \" << north << std::endl;\n+    // std::cout << \"East neighbour is: \" << east << std::endl;\n+    // std::cout << \"South neighbour is: \" << south << std::endl;\n+    // std::cout << \"West neighbour is: \" << west << std::endl;\n \n+    return neighborhood;\n+}\n \n+// Code to evaluate moore neighborhood where r = 1 with periodic bounds.\n+std::vector<int> CellularAutomata::moore_neighborhood(int row, int column)\n+{\n+    int north = _data[(_rows + ((row-1) % _rows) ) % _rows][column];\n+    int north_east = _data[(_rows + ((row-1) % _rows) ) % _rows][(_columns + ((column + 1) % _columns)) % _columns];\n+    int east = _data[row][(_columns + ((column + 1) % _columns)) % _columns];\n+    int south_east = _data[(_rows + ((row+1) % _rows) ) % _rows][(_columns + ((column + 1) % _columns)) % _columns];\n+    int south = _data[(_rows + ((row+1) % _rows) ) % _rows][column];\n+    int south_west = _data[(_rows + ((row+1) % _rows) ) % _rows][(_columns + ((column - 1) % _columns)) % _columns];\n+    int west = _data[row][(_columns + ((column - 1) % _columns)) % _columns];\n+    int north_west = _data[(_rows + ((row-1) % _rows) ) % _rows][(_columns + ((column - 1) % _columns)) % _columns];\n \n+    std::vector<int> neighborhood;\n+    neighborhood.push_back(north_west);\n+    neighborhood.push_back(north);\n+    neighborhood.push_back(north_east);\n+    neighborhood.push_back(west);\n+    neighborhood.push_back(east);\n+    neighborhood.push_back(south_west);\n+    neighborhood.push_back(south);\n+    neighborhood.push_back(south_east);\n \n+    // std::cout << \"North neighbour is: \" << north << std::endl;\n+    // std::cout << \"North East neighbour is: \" << north_east << std::endl;\n+    // std::cout << \"East neighbour is: \" << east << std::endl;\n+    // std::cout << \"South East neighbour is: \" << south_east << std::endl;    \n+    // std::cout << \"South neighbour is: \" << south << std::endl;\n+    // std::cout << \"South West neighbour is: \" << south_west << std::endl;\n+    // std::cout << \"West neighbour is: \" << west << std::endl;\n+    // std::cout << \"North West neighbour is: \" << north_west << std::endl;\n \n+    return neighborhood;\n+}\n+\n+std::vector<int> CellularAutomata::get_neighborhood(int x, int y,int neighborhood_num){\n+  switch(neighborhood_num) {\n+    case 1:\n+      return moore_neighborhood(x,y);\n+    case 2:\n+      return vn_neighborhood(x,y);\n+    default:\n+      return moore_neighborhood(x,y);\n+  }\n+}\n+\n+void CellularAutomata::run(int num_steps, int rule_num, int neighborhood_num){\n+  for(int i=0; i < num_steps; i++){\n+    step(rule_num, neighborhood_num);\n+    std::cout << \"Step \" << i << \": \" << std::endl;\n+    print();\n+  }\n+}\n+\n+//logic for taking a single step of the CA simluation todo: document the funciton\n+void CellularAutomata::step(int rule_num, int neighborhood_num){\n+  for(int x = 0; x < _columns; x++){\n+    for(int y = 0; y < _rows; y++){\n+      std::vector<int> neighborhood = get_neighborhood(x,y,neighborhood_num);\n+      _data[x][y] = transition_function(x,y,rule_num,neighborhood);\n+    }\n+  }\n+}\n+\n+\n+int CellularAutomata::transition_function(int x, int y, int rule_num, std::vector<int> neighborhood){\n+  switch(rule_num) {\n+    case 1:\n+      return majority_rule(x, y, neighborhood);\n+    case 2:\n+      return purity_rule(x,y,neighborhood);\n+    default:\n+      return _data[x][y];\n+  }\n+}\n+\n+// logic for the majority rule todo:  add additional function documentation\n+int CellularAutomata::majority_rule(int x, int y, std::vector<int> neighborhood){\n+  int sum = 0;\n+  for(int i = 0; i < neighborhood.size(); i++){\n+    sum += neighborhood[i];\n+  }\n+\n+  return round((double)sum/neighborhood.size());\n+}\n+\n+// logic for the purity rule todo:  add additional function documentation\n+int CellularAutomata::purity_rule(int x, int y, std::vector<int> neighborhood){\n+  int sum = 0;\n+  int current_val = _data[x][y];\n+  for(int i = 0; i < neighborhood.size(); i++){\n+    sum += (current_val+neighborhood[i]);\n+  }\n+\n+  return sum % _num_states;\n+}\n+\n+// Temporary print that is being used to test if the Initialize function is working as intended.\n+// Print the formatted matrix out to the terminal using std::cout. Each row is printed with the first element of the Cellular Automata following an opening square bracket and all elements being seperated by commas. The last element of the Cellular Automata is also followed by a closing square bracket.\n+void CellularAutomata::print()\n+{\n+    for(int i = 0; i < _rows; i++)\n+    {\n+        for(int j = 0; j < _columns; j++)\n+        {\n+            if ((i == _rows-1) && (j == _columns-1))\n+            {\n+                std::cout << _data[i][j] << \"]\";\n+            }\n+            else if ((i == 0) && (j == 0))\n+            {\n+                std::cout << \"[\" << _data[i][j] << \", \";\n+            }\n+            else\n+            {\n+                std::cout << _data[i][j] << \", \";\n+            }\n+        }\n+        std::cout << std::endl;\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n int main(void)\n {\n     // Testing the creation of a cellular automata when data is directly passed in\n     std::cout << \"Creating Cellular Automata given data: \" << std::endl;\n"
                },
                {
                    "date": 1639548255486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n \n #include <iostream>\n #include <utility>\n #include <math.h> \n-#include \"CellularAutomata.h\"\n+#include \"include/CellularAutomata.h\"\n #include \"myutils.h\"\n \n // Constructor with data being passed in from the user.\n CellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::vector<std::vector<int> > data, std::string product, std::string reactor, std::pair<int, int> starting_position)\n"
                },
                {
                    "date": 1639548273422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n #include <iostream>\n #include <utility>\n #include <math.h> \n #include \"include/CellularAutomata.h\"\n-#include \"myutils.h\"\n+#include \"utils/myutils.h\"\n \n // Constructor with data being passed in from the user.\n CellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::vector<std::vector<int> > data, std::string product, std::string reactor, std::pair<int, int> starting_position)\n {\n"
                },
                {
                    "date": 1639548287177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n #include <iostream>\n #include <utility>\n #include <math.h> \n #include \"include/CellularAutomata.h\"\n-#include \"utils/myutils.h\"\n+#include \"utils/utils.cxx\"\n \n // Constructor with data being passed in from the user.\n CellularAutomata::CellularAutomata(int rows, int columns, std::map<std::string, int> legend, std::vector<std::vector<int> > data, std::string product, std::string reactor, std::pair<int, int> starting_position)\n {\n"
                },
                {
                    "date": 1639550028731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,8 +281,12 @@\n         std::cout << std::endl;\n     }\n }\n \n+int main()\n+{\n+    \n+}\n \n \n \n \n@@ -297,9 +301,8 @@\n \n \n \n \n-\n int main(void)\n {\n     // Testing the creation of a cellular automata when data is directly passed in\n     std::cout << \"Creating Cellular Automata given data: \" << std::endl;\n"
                },
                {
                    "date": 1639550132937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,28 +281,16 @@\n         std::cout << std::endl;\n     }\n }\n \n-int main()\n-{\n-    \n-}\n \n \n \n \n \n \n \n \n-\n-\n-\n-\n-\n-\n-\n-\n int main(void)\n {\n     // Testing the creation of a cellular automata when data is directly passed in\n     std::cout << \"Creating Cellular Automata given data: \" << std::endl;\n"
                },
                {
                    "date": 1639550171025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,14 +283,8 @@\n }\n \n \n \n-\n-\n-\n-\n-\n-\n int main(void)\n {\n     // Testing the creation of a cellular automata when data is directly passed in\n     std::cout << \"Creating Cellular Automata given data: \" << std::endl;\n@@ -331,5 +325,18 @@\n     // Testing moore neighborhood analysis\n     Test_3.moore_neighborhood(0,5);\n     std::cout << std::endl;\n     std::cout << std::endl;\n+\n+        std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n+    std::map<std::string, std::pair<int, float>> test_legend_density{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n+    CellularAutomata Test1(10, 10, test_legend_density, \"char\", \"fire\", std::pair<int, int> {5, 5});\n+    //3 steps with majority rule and moore neighborhood;\n+    Test1.run(30,1,1); \n+\n+    // Testing the creation of a cellular automata when data is directly passed in\n+    CellularAutomata Test2(10, 10, test_legend_density, \"char\", \"fire\", (std::pair<int, int>) {5, 5});\n+    Test2.print();   \n+\n+    //3 steps with purity rule and moore neighborhood;\n+    Test2.run(30,2,1); \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1639550203290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,11 +326,11 @@\n     Test_3.moore_neighborhood(0,5);\n     std::cout << std::endl;\n     std::cout << std::endl;\n \n-        std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n+    std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n     std::map<std::string, std::pair<int, float>> test_legend_density{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n-    CellularAutomata Test1(10, 10, test_legend_density, \"char\", \"fire\", std::pair<int, int> {5, 5});\n+    CellularAutomata Test1(10, 10, test_legend_density_, \"char\", \"fire\", std::pair<int, int> {5, 5});\n     //3 steps with majority rule and moore neighborhood;\n     Test1.run(30,1,1); \n \n     // Testing the creation of a cellular automata when data is directly passed in\n"
                },
                {
                    "date": 1639550215798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -327,10 +327,10 @@\n     std::cout << std::endl;\n     std::cout << std::endl;\n \n     std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n-    std::map<std::string, std::pair<int, float>> test_legend_density{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n-    CellularAutomata Test1(10, 10, test_legend_density_, \"char\", \"fire\", std::pair<int, int> {5, 5});\n+    std::map<std::string, std::pair<int, float>> test_legend_density_{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n+    CellularAutomata Test1(10, 10, test_legend_density__, \"char\", \"fire\", std::pair<int, int> {5, 5});\n     //3 steps with majority rule and moore neighborhood;\n     Test1.run(30,1,1); \n \n     // Testing the creation of a cellular automata when data is directly passed in\n"
                },
                {
                    "date": 1639550225889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,9 @@\n     std::cout << std::endl;\n \n     std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n     std::map<std::string, std::pair<int, float>> test_legend_density_{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n-    CellularAutomata Test1(10, 10, test_legend_density__, \"char\", \"fire\", std::pair<int, int> {5, 5});\n+    CellularAutomata Test1(10, 10, test_legend_density_, \"char\", \"fire\", std::pair<int, int> {5, 5});\n     //3 steps with majority rule and moore neighborhood;\n     Test1.run(30,1,1); \n \n     // Testing the creation of a cellular automata when data is directly passed in\n"
                },
                {
                    "date": 1639585152383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,8 +326,9 @@\n     Test_3.moore_neighborhood(0,5);\n     std::cout << std::endl;\n     std::cout << std::endl;\n \n+\n     std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n     std::map<std::string, std::pair<int, float>> test_legend_density_{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n     CellularAutomata Test1(10, 10, test_legend_density_, \"char\", \"fire\", std::pair<int, int> {5, 5});\n     //3 steps with majority rule and moore neighborhood;\n"
                },
                {
                    "date": 1639585165420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -330,8 +330,10 @@\n \n     std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n     std::map<std::string, std::pair<int, float>> test_legend_density_{{\"empty\", {0, 0.1}}, {\"tree\", {1, 0.04}}, {\"fire\", {2, 0.7}}, {\"char\", {3, 0.16}}};\n     CellularAutomata Test1(10, 10, test_legend_density_, \"char\", \"fire\", std::pair<int, int> {5, 5});\n+    \n+    \n     //3 steps with majority rule and moore neighborhood;\n     Test1.run(30,1,1); \n \n     // Testing the creation of a cellular automata when data is directly passed in\n"
                },
                {
                    "date": 1639588055024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -225,9 +225,9 @@\n }\n \n \n int CellularAutomata::transition_function(int x, int y, int rule_num, std::vector<int> neighborhood){\n-  switch(rule_num) {\n+  switch(rule_num) {1\n     case 1:\n       return majority_rule(x, y, neighborhood);\n     case 2:\n       return purity_rule(x,y,neighborhood);\n"
                },
                {
                    "date": 1639589509276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,8 +248,9 @@\n \n // logic for the purity rule todo:  add additional function documentation\n int CellularAutomata::purity_rule(int x, int y, std::vector<int> neighborhood){\n   int sum = 0;\n+  \n   int current_val = _data[x][y];\n   for(int i = 0; i < neighborhood.size(); i++){\n     sum += (current_val+neighborhood[i]);\n   }\n"
                }
            ],
            "date": 1639548234824,
            "name": "Commit-0",
            "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint main(void)\n{\n    // Testing the creation of a cellular automata when data is directly passed in\n    std::cout << \"Creating Cellular Automata given data: \" << std::endl;\n    std::vector<std::vector<int>> test = {{1, 1, 1}, {1, 0, 1}, {0, 1, 2}};\n    std::map<std::string, int> test_legend{{\"empty\", 0}, {\"tree\", 1}, {\"fire\", 2}, {\"char\", 3}};\n    CellularAutomata Test(3, 3, test_legend, test, \"char\", \"fire\", std::pair<int, int> {2, 2});\n    Test.print();    \n    // Testing von neumaan neighborhood analysis\n    std::cout << \"Testing Von Neumaan Neighborhood funtionality around 2,2:\" << std::endl;\n    Test.vn_neighborhood(2, 2);\n    std::cout << std::endl;\n    std::cout << \"Testing Von Neumaan Neighborhood funtionality and periodic bounds around 0,0:\" << std::endl;\n    Test.vn_neighborhood(0, 0);\n    std::cout << std::endl;\n    std::cout << \"Testing Moore Neighborhood funtionality around 5,5:\" << std::endl;\n    // Testing moore neighborhood analysis\n    Test.moore_neighborhood(1, 1);\n    std::cout << std::endl;\n    std::cout << std::endl;\n\n    // Testint the creation of a cellular automata when data is directly passed in\n    std::cout << \"Creating Cellular Automata Randomly: \" << std::endl;\n    CellularAutomata Test_2(10, 10, test_legend, \"char\", \"fire\", std::pair<int, int> {5, 5});\n    Test_2.print();\n    // Testing von neumaan neighborhood analysis\n    std::cout << \"Testing Von Neumaan Neighborhood funtionality around 5, 5:\" << std::endl;\n    Test_2.vn_neighborhood(5,5);\n    std::cout << std::endl;\n    std::cout << std::endl;\n\n    std::cout << \"Creating Cellular Automata using Density: \" << std::endl;\n    std::map<std::string, std::pair<int, float>> test_legend_density{{\"empty\", {0, 0.5}}, {\"tree\", {1, 0.5}}, {\"fire\", {2, 0.0}}, {\"char\", {3, 0.0}}};\n    CellularAutomata Test_3(10, 10, test_legend_density, \"char\", \"fire\", std::pair<int, int> {5, 5});\n    Test_3.print();\n    Test_3.vn_neighborhood(5,5);\n    std::cout << std::endl;\n    std::cout << \"Testing Moore Neighborhood funtionality and periodic bounds around 0,5:\" << std::endl;\n    // Testing moore neighborhood analysis\n    Test_3.moore_neighborhood(0,5);\n    std::cout << std::endl;\n    std::cout << std::endl;\n}"
        }
    ]
}